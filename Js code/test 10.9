// main.js - Screeps åŸºç¤ä¸‰è§’è‰²ç³»çµ±
module.exports.loop = function () {
    
    // === æ¸…ç†è¨˜æ†¶é«” ===
    // æ¸…é™¤å·²æ­»äº¡ creep çš„è¨˜æ†¶ï¼Œé¿å…è¨˜æ†¶é«”æ´©æ¼
    for(let name in Memory.creeps) {
        if(!Game.creeps[name]) {
            delete Memory.creeps[name];
            console.log('æ¸…é™¤è¨˜æ†¶:', name);
        }]
    }

    // === è¨ˆç®—å„è§’è‰²æ•¸é‡ ===
    const harvesters = _.filter(Game.creeps, c => c.memory.role == 'harvester');
    const upgraders = _.filter(Game.creeps, c => c.memory.role == 'upgrader');
    const builders = _.filter(Game.creeps, c => c.memory.role == 'builder');
    
    // é¡¯ç¤ºç›®å‰ç‹€æ…‹
    console.log('ğŸ“Š Harvesters:' + harvesters.length + 
                ' | Upgraders:' + upgraders.length + 
                ' | Builders:' + builders.length);

    // === è‡ªå‹•ç”Ÿç”¢ Creep ===
    const spawn = Game.spawns['Spawn1']; // æ”¹æˆä½ çš„ Spawn åç¨±
    const room = spawn.room;

    // ========== æ–°å¢ï¼šä¾ RCL è‡ªå‹•æ”¾ Extension å·¥åœ° ==========
    // èªªæ˜ï¼š
    // - allowedExtensionsByRCLï¼šæ¯å€‹ RCL å¯å»ºçš„ extension ä¸Šé™ï¼ˆScreeps è¦å‰‡ï¼‰ã€‚
    // - findBuildPosNearSpawnï¼šåœ¨ spawn å‘¨åœæ‰¾å¯ä»¥æ”¾å·¥åœ°çš„ä½ç½®ï¼ˆé¿é–‹ç‰†ã€æ—¢æœ‰çµæ§‹èˆ‡å·¥åœ°ï¼‰ã€‚
    // - ä¸»æµç¨‹ï¼šè‹¥æˆ¿é–“æ—¢æœ‰ + å·¥åœ°æ•¸é‡ < ä¸Šé™ï¼Œå°±å˜—è©¦æ”¾æ–°çš„å·¥åœ°ã€‚

    function allowedExtensionsByRCL(level) {
        const map = {1:0, 2:5, 3:10, 4:20, 5:30, 6:40, 7:50, 8:60};
        return map[level] || 0;
    }

    function findBuildPosNearSpawn(spawn, maxRange = 4) {
        const room = spawn.room;
        const terrain = room.getTerrain();
        const p = spawn.pos;
        // å…ˆæ‰¾å¹³åœ°ï¼ˆéç‰†ã€éå·¥åœ°ã€éçµæ§‹ã€å„ªå…ˆéæ²¼æ¾¤ï¼‰ï¼Œç”±è¿‘åˆ°é 
        for (let r = 1; r <= maxRange; r++) {
            for (let dx = -r; dx <= r; dx++) {
                for (let dy = -r; dy <= r; dy++) {
                    const x = p.x + dx, y = p.y + dy;
                    if (x < 1 || x > 48 || y < 1 || y > 48) continue;
                    if (x === p.x && y === p.y) continue;
                    if (terrain.get(x, y) === TERRAIN_MASK_WALL) continue; // ç‰†ä¸å¯å»º
                    if (room.lookForAt(LOOK_STRUCTURES, x, y).length > 0) continue; // æœ‰çµæ§‹
                    if (room.lookForAt(LOOK_CONSTRUCTION_SITES, x, y).length > 0) continue; // æœ‰å·¥åœ°
                    // å„ªå…ˆå›å‚³å¹³åœ°ï¼ˆåŒ…å« swamp ä¹Ÿå¯ï¼Œè‹¥æƒ³åš´æ ¼é¿ swamp å¯å†åˆ¤æ–·ï¼‰
                    return new RoomPosition(x, y, room.name);
                }
            }
        }
        return null;
    }

    // ä¸»æµç¨‹ï¼šç•¶ RCL >= 2ï¼Œä¸”ç¾æœ‰ extensionï¼ˆå·²å»º + å·¥åœ°ï¼‰å°æ–¼ä¸Šé™æ™‚ï¼Œå˜—è©¦æ”¾å·¥åœ°
    if (room.controller) {
        const allowed = allowedExtensionsByRCL(room.controller.level);
        const existingExtCount = room.find(FIND_MY_STRUCTURES, {
            filter: s => s.structureType === STRUCTURE_EXTENSION
        }).length;
        const extSiteCount = room.find(FIND_MY_CONSTRUCTION_SITES, {
            filter: s => s.structureType === STRUCTURE_EXTENSION
        }).length;
        if (room.controller.level >= 2 && (existingExtCount + extSiteCount) < allowed) {
            const pos = findBuildPosNearSpawn(spawn, 4);
            if (pos) {
                const res = room.createConstructionSite(pos.x, pos.y, STRUCTURE_EXTENSION);
                if (res === OK) {
                    console.log('Placed extension site at', pos.x, pos.y, `(${existingExtCount + extSiteCount + 1}/${allowed})`);
                }
            }
        }
    }
    // ========== æ–°å¢çµæŸ ==========
    
    // å„ªå…ˆç´šï¼šHarvester > Upgrader > Builder
    if(harvesters.length < 2) {
        const newName = 'H' + Game.time;
        // è‹¥æˆ¿é–“ä¸€æ¬¡æ€§èƒ½é‡ï¼ˆspawn + extensionsï¼‰åˆ° 550ï¼Œçµ¦ä¸­ç­‰èº«é«”ï¼›å¦å‰‡çµ¦å°èº«é«”
        const body = (room.energyCapacityAvailable >= 550) ? [WORK,WORK,CARRY,MOVE,MOVE] : [WORK,CARRY,MOVE];
        spawn.spawnCreep(body, newName, {memory: {role: 'harvester'}});
    }
    else if(upgraders.length < 1) {
        const newName = 'U' + Game.time;
        const body = (room.energyCapacityAvailable >= 550) ? [WORK,WORK,CARRY,MOVE,MOVE] : [WORK,CARRY,MOVE];
        spawn.spawnCreep(body, newName, {memory: {role: 'upgrader'}});
    }
    else if(builders.length < 2) {
        const newName = 'B' + Game.time;
        const body = (room.energyCapacityAvailable >= 550) ? [WORK,WORK,CARRY,MOVE,MOVE] : [WORK,CARRY,MOVE];
        spawn.spawnCreep(body, newName, {memory: {role: 'builder'}});
    }

    // é¡¯ç¤ºç”Ÿç”¢ç‹€æ…‹
    if(spawn.spawning) {
        const spawningCreep = Game.creeps[spawn.spawning.name];
        spawn.room.visual.text(
            'ğŸ› ï¸ ' + spawningCreep.memory.role,
            spawn.pos.x + 1, 
            spawn.pos.y, 
            {align: 'left', opacity: 0.8});
    }

    // === åŸ·è¡Œå„ Creep çš„ä»»å‹™ ===
    for(let name in Game.creeps) {
        const creep = Game.creeps[name];
        
        // æ ¹æ“šè§’è‰²åŸ·è¡Œä¸åŒä»»å‹™
        if(creep.memory.role == 'harvester') {
            runHarvester(creep);
        }
        else if(creep.memory.role == 'upgrader') {
            runUpgrader(creep);
        }
        else if(creep.memory.role == 'builder') {
            runBuilder(creep);
        }
    }
}

// === Harvester è§’è‰²é‚è¼¯ ===
function runHarvester(creep) {
    // å¦‚æœèƒŒåŒ…æ»¿äº†ï¼Œå»è£œå…… Spawn
    if(creep.store.getFreeCapacity() == 0) {
        const target = creep.pos.findClosestByPath(FIND_STRUCTURES, {
            filter: (s) => {
                return (s.structureType == STRUCTURE_EXTENSION ||
                        s.structureType == STRUCTURE_SPAWN) &&
                       s.store.getFreeCapacity(RESOURCE_ENERGY) > 0;
            }
        });
        if(target) {
            if(creep.transfer(target, RESOURCE_ENERGY) == ERR_NOT_IN_RANGE) {
                creep.moveTo(target, {visualizePathStyle: {stroke: '#ffaa00'}});
            }
        }
    }
    // å¦å‰‡å»æ¡é›†
    else {
        const source = creep.pos.findClosestByPath(FIND_SOURCES);
        if(creep.harvest(source) == ERR_NOT_IN_RANGE) {
            creep.moveTo(source, {visualizePathStyle: {stroke: '#ffaa00'}});
        }
    }
}

// === Upgrader è§’è‰²é‚è¼¯ ===
function runUpgrader(creep) {
    // ç‹€æ…‹åˆ‡æ›ï¼šå·¥ä½œä¸­ / æ¡é›†ä¸­
    if(creep.memory.upgrading && creep.store[RESOURCE_ENERGY] == 0) {
        creep.memory.upgrading = false;
        creep.say('ğŸ”„ æ¡é›†');
    }
    if(!creep.memory.upgrading && creep.store.getFreeCapacity() == 0) {
        creep.memory.upgrading = true;
        creep.say('âš¡ å‡ç´š');
    }

    // åŸ·è¡Œä»»å‹™
    if(creep.memory.upgrading) {
        if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
            creep.moveTo(creep.room.controller, {visualizePathStyle: {stroke: '#00ff00'}});
        }
    }
    else {
        const source = creep.pos.findClosestByPath(FIND_SOURCES);
        if(creep.harvest(source) == ERR_NOT_IN_RANGE) {
            creep.moveTo(source, {visualizePathStyle: {stroke: '#00ff00'}});
        }
    }
}

// === Builder è§’è‰²é‚è¼¯ ===
function runBuilder(creep) {
    // ç‹€æ…‹åˆ‡æ›ï¼šå»ºé€ ä¸­ / æ¡é›†ä¸­
    if(creep.memory.building && creep.store[RESOURCE_ENERGY] == 0) {
        creep.memory.building = false;
        creep.say('ğŸ”„ æ¡é›†');
    }
    if(!creep.memory.building && creep.store.getFreeCapacity() == 0) {
        creep.memory.building = true;
        creep.say('ğŸ”¨ å»ºé€ ');
    }

    // åŸ·è¡Œä»»å‹™
    if(creep.memory.building) {
        const target = creep.pos.findClosestByPath(FIND_CONSTRUCTION_SITES);
        if(target) {
            if(creep.build(target) == ERR_NOT_IN_RANGE) {
                creep.moveTo(target, {visualizePathStyle: {stroke: '#ffffff'}});
            }
            else{
                creep.say('ğŸ æ»¿äº†!'); // å¦‚æœæ‰¾ä¸åˆ°ç›®æ¨™ï¼Œå®ƒæœƒèªªè©±
            }
        }
        // å¦‚æœæ²’æœ‰å»ºç¯‰å·¥åœ°ï¼Œå°±å»å‡ç´šæ§åˆ¶å™¨
        else {
            if(creep.upgradeController(creep.room.controller) == ERR_NOT_IN_RANGE) {
                creep.moveTo(creep.room.controller, {visualizePathStyle: {stroke: '#ffffff'}});
            }
        }
    }
    else {
        const source = creep.pos.findClosestByPath(FIND_SOURCES);
        if(creep.harvest(source) == ERR_NOT_IN_RANGE) {
            creep.moveTo(source, {visualizePathStyle: {stroke: '#ffffff'}});
        }
    }
}